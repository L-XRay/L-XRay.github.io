<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HashMap源码(上)</title>
      <link href="/posts/235dfb88.html"/>
      <url>/posts/235dfb88.html</url>
      
        <content type="html"><![CDATA[<p>HashMap 最早出现在JDK1.2中，底层基于散列算法实现</p><ul><li>HashMap <strong>允许null 键和null 值</strong>，在计算哈键的哈希值时，<strong>null 键哈希值为0</strong>。</li><li>HashMap <strong>并不保证键值对的顺序</strong>，这意味着在进行某些操作后，键值对的顺序可能会发生变化。</li><li>HashMap 是<strong>非线程安全类</strong>，在多线程环境下可能会存在问题。</li></ul><p>HashMap在JDK 1.8中包括；1、散列表实现、2、扰动函数、3、初始化容量、4、负载因子、5、扩容元素拆分、6、链表树化、7、红黑树、8、插入、9、查找、10、删除、11、遍历、12、分段锁等等<br>这里我们先把目光放在前五项上，也就是关于数据结构的使用上。</p><h1 id="散列表实现（一个简单的HashMap）"><a href="#散列表实现（一个简单的HashMap）" class="headerlink" title="散列表实现（一个简单的HashMap）"></a>散列表实现（一个简单的HashMap）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;power&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;technology&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;environment&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] tab = <span class="keyword">new</span> <span class="title class_">String</span>[list.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line">            <span class="comment">// 计算索引: 指定value的hash值 按位与 tab最大下标 保证不越界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> value.hashCode() &amp; (tab.length - <span class="number">1</span>);</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;key: %d, value: %s&quot;</span>,key,value));</span><br><span class="line">            <span class="comment">// 如果数组当前索引中不存在value,赋值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == tab[key]) &#123;</span><br><span class="line">                tab[key] = value;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 存在则将其链接起来</span></span><br><span class="line">            tab[key] = tab[key]+ <span class="string">&quot;-&gt;&quot;</span>+ value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(tab));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/hashmap-simple.png" alt="hashmap-simple"></p><h3 id="所存在的问题"><a href="#所存在的问题" class="headerlink" title="所存在的问题"></a>所存在的问题</h3><ol><li>所有的元素存放都需要一个索引位置，如果索引位置不够导致散列碰撞严重，那就没有达到预期的性能，也就失去了散列表的意义</li><li>在获取索引 ID 的计算公式中，需要数组长度是 2 的倍数（需要保证能进行按位与操作不越界），数组大小如何设定？</li><li>数组越小碰撞越大，数组越大碰撞越小，如何取舍时间与空间？</li><li>目前存放 7 个元素，已经有两个位置都存放了 2 个字符串，那么链表越来越长怎么优化？</li><li>随着元素的不断添加，数组长度不足扩容时，怎么把原有的元素拆分到新的位置上去？</li></ol><p>以上这些问题可以归纳为；扰动函数、初始化容量、负载因子、扩容方法以及链表和红黑树转换的使用等。</p><h1 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h1><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/hashmap-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0.png" alt="hashmap-扰动函数"><br>在 HashMap 存放元素时候有这样一段代码来处理哈希值，这是 Java 8 的散列值扰动函数，用于优化散列效果。<br>理论上来说字符串的 hashCode是一个 int 类型值，那可以直接作为数组下标了，且不会出现碰撞。但是这个 hashCode 的取值范围是[-2147483648, 2147483647]， 有将近 40 亿的长度，谁也不能把数组初始化的这么大，内存也是放不下的。 我们<strong>默认初始化的 Map 大小是 16 个长度。</strong>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4， 所以获取的 Hash 值并不能直接作为下标使用，需要与数组长度进行取模运算得到一个下标值，也就是我们上面做的散列列子。<br>hashMap 源码这里不只是直接获取哈希值，还进行了一次扰动计算，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)。把哈希值右移 16 位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了<strong>随机性</strong>。<br><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/HashMap-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0.drawio.png" alt="HashMap-扰动函数.drawio"><br>使用扰动函数就是为了增加随机性，让数据元素更加均衡的散列，减少hash碰撞，让数据存放和获取的效率更好</p><h1 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h1><p>散列数组需要一个 2 的倍数的长度，因为只有 2 的 倍数在减 1 的时候，才会出现 01111 这样的值。那么这里就有一个问题，我们在初始化 HashMap 的时候，如果传一个 17 个的值 new HashMap&lt;&gt;(17);，它会怎么处理呢？</p><h2 id="寻找最小二进制数"><a href="#寻找最小二进制数" class="headerlink" title="寻找最小二进制数"></a>寻找最小二进制数</h2><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/hashmap-%E5%AF%BB%E6%89%BE%E6%9C%80%E5%B0%8F2%E7%9A%84n%E6%96%B9%E6%95%B0.png" alt="hashmap-寻找最小2的n方数"></p><ul><li>在 HashMap 的初始化中，阀值 threshold，通过方法 tableSizeFor 进行计算，是根据初始化大小来计算的。</li><li>这个方法也就是要寻找比初始值大的，最小的那个 2 进制数值。比如传了 17，我应该找到的是 32。</li></ul><p>计算阀值大小的方法：<br><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/hashmap-tableSizeFor.png" alt="hashmap-tableSizeFor"></p><ul><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，这个是临界范围，也就是最大容量。</li><li>乍一看可能有点晕😵怎么都在向右移位 1、2、4、8、16，这主要是为了 把二进制的各个位置都填上 1，当二进制的各个位置都是 1 以后，就是 一个标准的 2 的倍数减 1 了，最后把结果加 1 再返回即可。</li></ul><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/HashMap-%E8%AE%A1%E7%AE%97%E9%98%88%E5%80%BC.drawio.png" alt="HashMap-计算阈值.drawio"></p><h1 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">* by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">* MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>负载因子，可以理解成一辆车可承重重量超过某个阀值时，把货放到新的车上。<br><strong>在 HashMap 中，负载因子决定了数据量多少了以后进行扩容。</strong><br><em>这里要提到上面做的 HashMap 例子，我们准备了 6 个元素，但是最后还有 2 个位置空余，2 个 </em><br><em>位置存放了 2 个元素。 </em><br>所以可能即使你数据与数组容量一样大时也不一定能正正好好的把数组占满的，而是在某些小标位置出现了大量的碰撞，只能在同一个位置用链表存放，那么这样就失去了 Map 数组的性能。<br>要选择一个合理的大小下进行扩容，默认值 0.75 就是说当阀值容量占了 3/4 时赶紧扩容，减少 Hash 碰撞。同时 0.75 是一个默认构造值，在创建 HashMap 也可以调整，比如你希望用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</p><h1 id="扩容元素拆分"><a href="#扩容元素拆分" class="headerlink" title="扩容元素拆分"></a>扩容元素拆分</h1><p>为什么扩容，因为数组长度不足了。那扩容最直接的问题，就是需要把元素拆分到新的数组中。拆分元素的过程中，原 jdk1.7 中会需要重新计算哈希值，但是到 jdk1.8 中已经进行优化，不在需要重新计算，提升了拆分的性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;power&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;technology&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;environment&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;sad&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;god&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;yeah&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;uncle&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C#&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;GO&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String value : list) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> value.hashCode() ^ (value.hashCode() &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">key16</span> <span class="operator">=</span> hash &amp; (<span class="number">16</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">key32</span> <span class="operator">=</span> hash &amp; (<span class="number">32</span> - <span class="number">1</span>);</span><br><span class="line">            System.out.println(</span><br><span class="line">                <span class="string">&quot;value:&quot;</span> + value +</span><br><span class="line">                <span class="string">&quot;\n\tkey(16):&quot;</span> + key16 +</span><br><span class="line">                <span class="string">&quot;\tBit值:&quot;</span> + Integer.toBinaryString(hash) + <span class="string">&quot; - &quot;</span> + Integer.toBinaryString(hash &amp; <span class="number">16</span>) +</span><br><span class="line">                <span class="string">&quot;\n\tkey(32):&quot;</span> + key32 +</span><br><span class="line">                <span class="string">&quot;\tBit值:&quot;</span> + Integer.toBinaryString(hash) + <span class="string">&quot; - &quot;</span> + Integer.toBinaryString(hash &amp; (<span class="number">32</span> - <span class="number">1</span>))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">value:one</span><br><span class="line">key(16):7Bit值:11010111001100111 - 0</span><br><span class="line">key(32):7Bit值:11010111001100111 - 111</span><br><span class="line">value:power</span><br><span class="line">key(16):11Bit值:110010111101000111101011011 - 10000</span><br><span class="line">key(32):27Bit值:110010111101000111101011011 - 11011</span><br><span class="line">value:technology</span><br><span class="line">key(16):11Bit值:10011011111001110001111011101011 - 0</span><br><span class="line">key(32):11Bit值:10011011111001110001111011101011 - 1011</span><br><span class="line">value:environment</span><br><span class="line">key(16):2Bit值:11111010111000011100100011110010 - 10000</span><br><span class="line">key(32):18Bit值:11111010111000011100100011110010 - 10010</span><br><span class="line">value:hello</span><br><span class="line">key(16):11Bit值:101111010010001110100111011 - 10000</span><br><span class="line">key(32):27Bit值:101111010010001110100111011 - 11011</span><br><span class="line">value:world</span><br><span class="line">key(16):3Bit值:110110000010001110101010011 - 10000</span><br><span class="line">key(32):19Bit值:110110000010001110101010011 - 10011</span><br><span class="line">value:good</span><br><span class="line">key(16):13Bit值:1100001000000010001101 - 0</span><br><span class="line">key(32):13Bit值:1100001000000010001101 - 1101</span><br><span class="line">value:sad</span><br><span class="line">key(16):7Bit值:11011101111010111 - 10000</span><br><span class="line">key(32):23Bit值:11011101111010111 - 10111</span><br><span class="line">value:god</span><br><span class="line">key(16):13Bit值:11001000001111101 - 10000</span><br><span class="line">key(32):29Bit值:11001000001111101 - 11101</span><br><span class="line">value:yeah</span><br><span class="line">key(16):11Bit值:1110001000100000001011 - 0</span><br><span class="line">key(32):11Bit值:1110001000100000001011 - 1011</span><br><span class="line">value:uncle</span><br><span class="line">key(16):7Bit值:110101001000011100101000111 - 0</span><br><span class="line">key(32):7Bit值:110101001000011100101000111 - 111</span><br><span class="line">value:Java</span><br><span class="line">key(16):1Bit值:1000110001111001100001 - 0</span><br><span class="line">key(32):1Bit值:1000110001111001100001 - 1</span><br><span class="line">value:PHP</span><br><span class="line">key(16):9Bit值:10011010101011001 - 10000</span><br><span class="line">key(32):25Bit值:10011010101011001 - 11001</span><br><span class="line">value:C#</span><br><span class="line">key(16):0Bit值:100001000000 - 0</span><br><span class="line">key(32):0Bit值:100001000000 - 0</span><br><span class="line">value:C</span><br><span class="line">key(16):3Bit值:1000011 - 0</span><br><span class="line">key(32):3Bit值:1000011 - 11</span><br><span class="line">value:Python</span><br><span class="line">key(16):15Bit值:10001111011000111001001110011111 - 10000</span><br><span class="line">key(32):31Bit值:10001111011000111001001110011111 - 11111</span><br><span class="line">value:GO</span><br><span class="line">key(16):8Bit值:100011101000 - 0</span><br><span class="line">key(32):8Bit值:100011101000 - 1000</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>这里我们随机使用一些字符串计算他们分别在 16 位长度和 32 位长度数组下的索引分配情况，看哪些数据被重新路由到了新的地址<br>同时，这里还可以观察出一个非常重要的信息，原哈希值与扩容新增出来的长度 16，进行&amp;运算，如果值等于 0，则下标位置不变。如果不为 0，那么新的位置则是原来位置上加 16。多次测试发现这里的16可以扩展为 2 的n次方。即：<br><strong>原哈希值（扰动哈希）与扩容新增出来的长度</strong> <strong>2 的 n 次方，进行&amp;运算</strong></p><ul><li><strong>如果值等于 0，则下标位置不变。</strong></li><li><strong>如果不为 0，那么新的位置则是原来位置上加 16</strong></li></ul><p><strong>由此可见,java 8 的散列值扰动函数，在优化散列效果的同时，也让扩容元素变得更加的方便。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 我的学习日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnowFlake算法</title>
      <link href="/posts/9a32a87d.html"/>
      <url>/posts/9a32a87d.html</url>
      
        <content type="html"><![CDATA[<p>snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。</p><p>其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。</p><h2 id="具体介绍"><a href="#具体介绍" class="headerlink" title="具体介绍"></a>具体介绍</h2><p>雪花算法是 64 位 的二进制，一共包含了四部分：</p><ul><li>1位是符号位，也就是最高位，始终是0，没有任何意义，因为要是唯一计算机二进制补码中就是负数，0才是正数。</li><li>41位是时间戳，具体到毫秒，41位的二进制可以使用69年，因为时间理论上永恒递增，所以根据这个排序是可以的。</li><li>10位是机器标识，可以全部用作机器ID，也可以用来标识机房ID + 机器ID，10位最多可以表示1024台机器。</li><li>12位是计数序列号，也就是同一台机器上同一时间，理论上还可以同时生成不同的ID，12位的序列号能够区分出4096个ID。</li></ul><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/snowflake.png" alt="snowflake"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.ray.domain.support.ids;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/10/12 16:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 雪花算法生成随机ID</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(SnowFlake.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心(机房)ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> dataCenterId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同一时间的序列号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> sequence;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳:2020-05-20 08:00:00 +0800 CST</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1589923200000L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机房ID所占位数 5bit 最大:11111(二进制)--&gt;31(十进制)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dataCenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID所占位数 5bit 最大:11111(二进制)--&gt;31(十进制)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同一时间的序列号所占位数 12bit 最大:111111111111(二进制)--&gt;4095(十进制)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5 bit最多只能有31个数字，即机房id数量最多只能是32以内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDataCenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; dataCenterIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 5 bit最多只能有31个数字，即机器id数量最多只能是32以内</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号掩码(0b111111111111==&gt;0xfff==&gt;4096)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机房ID偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dataCenterIdShift</span> <span class="operator">=</span> workerIdBits + sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳偏移量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> dataCenterIdBits + workerIdBits + sequenceBits;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最近一次时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowFlake</span><span class="params">(<span class="type">long</span> dataCenterId, <span class="type">long</span> workerId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(dataCenterId,workerId,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowFlake</span><span class="params">(<span class="type">long</span> dataCenterId, <span class="type">long</span> workerId, <span class="type">long</span> sequence)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( dataCenterId&gt;maxDataCenterId || dataCenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;机房ID 大于最大值 %d 或者 小于 0&quot;</span>,maxDataCenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( workerId&gt;maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;机器ID 大于最大值 %d 或者 小于 0&quot;</span>,maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;机器启动中: 时间戳偏移量:&#123;&#125;,机房ID占位:&#123;&#125;,机器ID占位:&#123;&#125;,序列号占位:&#123;&#125;,机器ID:&#123;&#125;&quot;</span>,</span><br><span class="line">                timestampLeftShift,dataCenterIdBits,workerIdBits,sequenceBits,workerId);</span><br><span class="line">        <span class="built_in">this</span>.dataCenterId = dataCenterId;</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.sequence = sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取机房ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 机房ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDataCenterId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataCenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取机器ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 机器ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getWorkerId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> workerId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取最新的时间戳</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 上一次生成ID的时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个随机ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 随机ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentTimestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;时间回退,最新时间戳:&#123;&#125;&quot;</span>,lastTimestamp);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;时间回退,拒绝生成ID,实际相差: %d&quot;</span>,lastTimestamp - currentTimestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span> (currentTimestamp == lastTimestamp) &#123;</span><br><span class="line">            sequence = (sequenceMask+<span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 sequence 序列号 大于 4095</span></span><br><span class="line">            <span class="keyword">if</span>(sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                currentTimestamp = nextTimestamp(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是当前时间第一次生成ID,就初始化为0</span></span><br><span class="line">            sequence = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最新时间戳</span></span><br><span class="line">        lastTimestamp = currentTimestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偏移计算生成随机ID</span></span><br><span class="line">        <span class="keyword">return</span> ((currentTimestamp - twepoch) &lt;&lt; timestampLeftShift) |</span><br><span class="line">                (dataCenterId &lt;&lt; dataCenterIdShift) |</span><br><span class="line">                (workerId &lt;&lt; workerIdShift) |</span><br><span class="line">                sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">nextTimestamp</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前时间戳小于等于 序列号已经超过4095 那个时间戳</span></span><br><span class="line">        <span class="comment">// 继续获取最新时间戳</span></span><br><span class="line">        <span class="keyword">if</span> (currentTimestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            currentTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1314261683.cos.ap-chongqing.myqcloud.com/image/snowflake_shift.png" alt="snowflake_shift"></p><ul><li>最后将三部分(时间戳、机器ID、序列号)按照偏移量进行移位操作，然后按位或将其组合即可得到随机生成的唯一ID</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>由于41位是时间戳，我们的时间计算是从1970年开始的，只能使用69年，为了不浪费，其实我们可以用时间的相对值，也就是以项目开始的时间为基准时间，往后可以使用69年。获取唯一ID的服务，对处理速度要求比较高，所以我们全部使用位运算以及位移操作，获取当前时间可以使用<code>System.currentTimeMillis()</code>。</p></li><li><h3 id="时间回拨问题"><a href="#时间回拨问题" class="headerlink" title="时间回拨问题"></a>时间回拨问题</h3><p>在获取时间的时候，可能会出现<code>时间回拨</code>的问题，时间回拨其实就是服务器上的时间突然倒退到之前的时间。</p><ol><li>人为原因，把系统环境的时间改了。</li><li>有时候不同的机器上需要同步时间，可能不同机器之间存在误差，那么可能会出现时间回拨问题。</li></ol><p><strong>解决方案</strong></p><ol><li>回拨时间小的时候，不生成 ID，循环等待到时间点到达。</li><li>上面的方案只适合时钟回拨较小的，如果间隔过大，阻塞等待，肯定是不可取的，因此要么超过一定大小的回拨直接报错，拒绝服务，或者有一种方案是利用拓展位，回拨之后在拓展位上加1就可以了，这样ID依然可以保持唯一。但是这个要求我们提前预留出位数，要么从机器id中，要么从序列号中，腾出一定的位，在时间回拨的时候，这个位置 <code>+1</code>。</li></ol></li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="1-第一位为什么不使用"><a href="#1-第一位为什么不使用" class="headerlink" title="1. 第一位为什么不使用?"></a>1. 第一位为什么不使用?</h3><p>在计算机的表示中，第一位是符号位，0表示整数，第一位如果是1则表示负数，我们用的ID默认就是正数，所以默认就是0，那么这一位默认就没有意义。</p><h3 id="2-机器位怎么用？"><a href="#2-机器位怎么用？" class="headerlink" title="2.机器位怎么用？"></a>2.机器位怎么用？</h3><p>机器位或者机房位，一共10 bit，如果全部表示机器，那么可以表示1024台机器，如果拆分，5 bit 表示机房，5bit表示机房里面的机器，那么可以有32个机房，每个机房可以用32台机器。</p><h3 id="3-twepoch表示什么？"><a href="#3-twepoch表示什么？" class="headerlink" title="3. twepoch表示什么？"></a>3. twepoch表示什么？</h3><p>由于时间戳只能用69年，我们的计时又是从1970年开始的，所以这个<code>twepoch</code>表示从项目开始的时间，用生成ID的时间减去<code>twepoch</code>作为时间戳，可以使用更久。</p><h3 id="4-1L-1L-lt-lt-x-表示什么？"><a href="#4-1L-1L-lt-lt-x-表示什么？" class="headerlink" title="4. -1L ^ (-1L &lt;&lt; x) 表示什么？"></a>4. -1L ^ (-1L &lt;&lt; x) 表示什么？</h3><p>表示 x 位二进制可以表示多少个数值，假设x为3：</p><p>在计算机中，第一位是符号位，负数的反码是除了符号位，1变0，0变1, 而补码则是反码+1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-1L 原码：1000 0001</span><br><span class="line">-1L 反码：1111 1110</span><br><span class="line">-1L 补码：1111 1111</span><br></pre></td></tr></table></figure><p>从上面的结果可以知道，<strong>-1L其实在二进制里面其实就是全部为1</strong>,那么 -1L 左移动 3位，其实得到 <code>1111 1000</code>，也就是最后3位是0，再与<code>-1L</code>异或计算之后，其实得到的，就是后面3位全是1。</p><p><code>-1L ^ (-1L &lt;&lt; x)</code>表示的其实就是x位全是1的值，也就是x位的二进制能表示的最大数值。</p><h3 id="5-时间戳比较"><a href="#5-时间戳比较" class="headerlink" title="5.时间戳比较"></a>5.时间戳比较</h3><p>在获取时间戳小于上一次获取的时间戳的时候，不能生成ID，而是继续循环，直到生成可用的ID，这里没有使用拓展位防止时钟回拨。</p><h3 id="6-前端直接使用发生精度丢失"><a href="#6-前端直接使用发生精度丢失" class="headerlink" title="6.前端直接使用发生精度丢失"></a>6.前端直接使用发生精度丢失</h3><p>如果前端直接使用服务端生成的 long 类型 id，会发生精度丢失的问题，因为 JS 中Number是16位的（指的是十进制的数字），而雪花算法计算出来最长的数字是19位的，这个时候需要用 String 作为中间转换，输出到前端即可。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="/posts/784dd132.html"/>
      <url>/posts/784dd132.html</url>
      
        <content type="html"><![CDATA[<p>this is Test</p><div class="table-container"><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/L-XRay"><img src="https://github-readme-stats.vercel.app/api/?username=L-XRay&theme=calm&show_owner=true"/></a></td></tr></tbody></table></div><div class="video"><video controls preload><source src='https://www.bilibili.com/bangumi/play/ep64315?from_spmid=666.4.feed.12' type='video/mp4'>Your browser does not support the video tag.</video></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
